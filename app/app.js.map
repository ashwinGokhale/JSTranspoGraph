{"version":3,"file":"app.js","sources":["src/lib/vehicle.js","src/lib/graph.js","src/lib/edge.js","src/lib/location.js","src/lib/passenger.js","src/settings/settings.js","src/sketch.js","src/app.js"],"sourcesContent":["/**\n * Created by ashwin on 2/25/17.\n */\n\nexport default class Vehicle {\n    static vehicleNames = [\"Aircraft\", \"Bart\", \"Bicycle\", \"Bus\", \"Car\", \"Taxi\"];\n\n    constructor(name, speedOfTravel, waitTime, unitCost, typeOfCost) {\n        this.name = name;\n        this.speedOfTravel = speedOfTravel;\n        this.waitTime = waitTime;\n        this.unitCost = unitCost;\n        this.typeOfCost = typeOfCost;\n        this.location = undefined;\n    }\n\n    toString = () => {\n        return this.name;\n    };\n\n    calculateCostOfTravel(distance){\n\t\t// typeOfCost: 1 is fixed (regardless of time or distance), 2 is fixed + a factor of distance  (e.g. a Taxi cab),\n\t\t// and 3 is based on fraction of distance (e.g. a Car where unitCost is expressed as cost/gallon)\n\n\t\tswitch (this.typeOfCost){\n\t\t\tcase 1:\n\t\t\t\treturn this.unitCost; // Fixed Cost\n\n\t\t\tcase 2:\n\t\t\t\treturn this.unitCost + (distance * 2); // Fixed Cost + $2 per mile\n\n\t\t\tcase 3:\n\t\t\t\treturn (this.unitCost / 25) * distance; // Cost per gallon per mile. $3 a gallon and 25 mpg\n\n\t\t\tdefault:\n\t\t\t\treturn 0.0;\n\t\t}\n\t}\n\n}","/**\n * Created by ashwi on 2/13/2017.\n */\n\nimport TinyQueue from 'tinyqueue'\n//const TinyQueue = require('tinyqueue');\nimport { vehicles } from '../settings/settings'\n\nexport default class Graph{\n\tconstructor() {\n\t\tthis.graph = {};\n\t}\n\n\taddVertex(node){\n\t\tthis.graph[node.name] = node;\n\t};\n\n\tcontainsLocation(node) {\n\t\treturn this.graph[node.name] != undefined;\n\t};\n\n\taddEdge(from, to, weight, type) {\n\t\tif (!this.containsLocation(from))\n\t\t\tthis.addVertex(from);\n\n\t\tif (!this.containsLocation(to))\n\t\t\tthis.addVertex(to);\n\n\t\tfrom.addNeighbor(to, weight, type);\n\t\tto.addNeighbor(from, weight, type);\n\t};\n\n\t// Implementation of Dijkstra's algorithm\n\t// Computes paths for each Passenger p\n\tcomputePaths(p) {\n\n\t\tvar source = p.currentLoc;\n\n\t\t// Must reset every location distance and previous values upon each function call\n\t\tObject.values(this.graph).forEach((x) => {\n\t\t\tx.dist = Infinity;\n\t\t\tx.prev = null;\n\t\t});\n\t\t\n\n\t\tsource.dist = 0;\n\t\tvar vertexQueue = new TinyQueue([], (a,b) => {\n\t\t\treturn a && b ? (a.dist < b.dist ? -1 : a.dist > b.dist ? 1: 0): 0;\n\t\t});\n\t\tvertexQueue.push(source);\n\n\t\twhile (vertexQueue.peek()) {\n\n\t\t\t// Pop the Location with the least distance\n\t\t\tlet u = vertexQueue.pop();\n\n\t\t\t// Visit each edge exiting u with the specified vehicle preference\n\t\t\tlet pref = p.vehiclePreference;\n\t\t\tlet adj = u.adjacent;\n\t\t\tadj.get(vehicles.get(p.vehiclePreference)).forEach((e) => {\n\t\t\t\tlet v = e.to;\t// Location v\n\t\t\t\tlet alt = u.dist + e.weight;\t// Calculate alternative cost (double)\n\t\t\t\tif (alt < v.dist) {\n\t\t\t\t\t// Remove v from priority queue\n\t\t\t\t\tvertexQueue.data.filter((loc) => loc == v);\n\n\t\t\t\t\tv.dist = alt;\n\t\t\t\t\tv.prev = u;\n\t\t\t\t\tvertexQueue.push(v);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n};\n\nexport const getShortestPathTo = (target) => {\n\tvar path = [];\n\tfor (var vertex = target; vertex != null; vertex = vertex.prev)\n\tpath.push(vertex);\n\n\tpath.reverse();\n\n\t// If no possible path, path will be [currentLoc, currentLoc]\n\tif (path.length == 1)\n\t\tpath.push(path[0]);\n\n\treturn path;\n};","/**\n * Created by ashwin on 2/25/17.\n */\n\nexport default class Edge {\n    constructor(from, to, weight, vehicleType) {\n        this.from = from;\n        this.to = to;\n        this.weight = weight;\n        this.vehicleType = vehicleType;\n    }\n}\n\n// function Edge (from, to, weight, vehicleType) {\n\n//     this.from = from;\n//     this.to = to;\n//     this.weight = weight;\n//     this.vehicleType = vehicleType;\n// }\n\n// module.exports = {\n//     createPaths: () => {\n//         const Location = require('./location');\n//         //const Graph = require('./graph');\n//         const pathsTxt = fs.readFileSync(path.resolve(__dirname, '../settings/Paths.txt'), 'utf8');\n//         const lines = pathsTxt.trim().split(/\\s*[\\r\\n]+\\s*/g).slice(1);    // startPoint,destPoint\n//         return lines.map((line) => {\n//             var payload = line.split(\",\");\n\n//             var from = Graph.graph[payload[0]];\n//             var to = Graph.graph[payload[1]];\n//             for (var i = 0; i < 6; i++) {\n//                 if (from.vehicleTypes[i] && to.vehicleTypes[i])\n//                     Graph.addEdge(from, to, Location.getDistance(from,to), from.vehicles[i]);\n//             }\n\n//         })\n//     },\n//     createEdge: (from, to, weight, vehicleType) => {\n//         return new Edge(from, to, weight, vehicleType);\n//     }\n// };\n","const path = require('path');\n\nimport Vehicle from './vehicle';\nimport Graph from './graph';\nimport Edge from './edge';\n\nexport default class Location {\n    constructor(name, latitude, longitude, x, y, vehicleTypes, vehicles) {\n        this.name = name;\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.vehicleTypes = vehicleTypes;\n\t\tthis.vehicles = vehicles;\n\t\tthis.lat = latitude;\n\t\tthis.lon = longitude;\n        this.dist = Infinity;\n\n\t\t// Initialize Adjacency HashMap and map each vehicle to an ArrayList of Edges\n\t\tthis.adjacent = new Map();\n        vehicles.forEach((vehicle) => {\n            if (vehicle) {\n                this.adjacent.set(vehicle, []);\n            }\n        });\n    }\n\n    addNeighbor = (neighbor, weight, vehicle) => {\n        // var e = new Edge(this, neighbor, weight, vehicle);\n        // if (this.adjacent[vehicle.name] != undefined && !this.adjacent[vehicle.name].includes(e)) {\n        //     this.adjacent[vehicle.name].push(e);\n        // }\n\n        let e = new Edge(this, neighbor, weight , vehicle);\n\t\tif (!this.adjacent.get(vehicle).includes(e))\n\t\t\tthis.adjacent.get(vehicle).push(e);\n    };\n}\n\n// function Location(line) {\n    // let i;\n\n    // // Split each line into its respective parameters\n    // var payload = line.split(\",\");\n\n    // // // Split vehicle types and parse them based on their values\n    // var types = payload[5].split(\"|\");\n    // var vehicleTypes = new Array(types.length);\n    // for (i = 0; i < types.length; i++)\n    //     vehicleTypes[i] = types[i] === \"1\";\n\n\n    // var vehiclePayload = [];\n\n    // // Initialize all Vehicles at that location\n    // for (i = 0; i < vehicleTypes.length; i++) {\n    //     if (vehicleTypes[i]) {\n    //         let v = Vehicle.getVehicle(Vehicle.vehicleNames[i]);\n    //         vehiclePayload.push(v);\n    //     } else\n    //         vehiclePayload.push(null);\n    // }\n\n//     this.name = payload[0];\n//     this.x = parseFloat(payload[3]);\n//     this.y = parseFloat(payload[4]);\n//     this.vehicleTypes = vehicleTypes;\n//     this.vehicles = vehiclePayload;\n//     this.lat = parseInt(payload[1]);\n//     this.lon = parseInt(payload[2]);\n//     this.dist = Infinity;\n//     this.prev = null;\n\n//     // Initialize Adjacency HashMap and map each vehicle to an ArrayList of Edges\n\n//     this.adjacent = {};\n//     vehiclePayload.forEach((payload) => {\n//         if (payload) {\n//             this.adjacent[payload.name] = [];\n//         }\n//     })\n// }\n\n// Location.prototype.addNeighbor = function(neighbor, weight, vehicle) {\n//     var e = Edge.createEdge(this, neighbor, weight, vehicle);\n//     if (this.adjacent[vehicle.name] != undefined && !this.adjacent[vehicle.name].includes(e)) {\n//         this.adjacent[vehicle.name].push(e);\n//     }\n// };\n\nexport const getDistance = (loc1, loc2) => {\n    return Math.sqrt(Math.pow(loc2.x - loc1.x, 2) + Math.pow(loc2.y - loc1.y, 2));\n};\n\nexport const getHaversineDistance = (l1, l2) => {\n    var lat1 = l1.lat;\n    var lon1 = l1.lon;\n    var lat2 = l2.lat;\n    var lon2 = l2.lon;\n\n    var R = 6371; // meters\n\n    var φ1 = Math.PI / 180 * (lat1);\n    var φ2 = Math.PI / 180 * (lat2);\n    var Δφ = Math.PI / 180 * (lat2 - lat1);\n    var Δλ = Math.PI / 180 * (lon2 - lon1);\n\n    var a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +\n        Math.cos(φ1) * Math.cos(φ2) *\n        Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    var d = R * c;\n\n    return d * 0.621371;\n};\n\n// module.exports = {\n//     getLocations: () => {\n//         const locationsTxt = fs.readFileSync(path.resolve(__dirname, '../settings/Locations.txt'), 'utf8');\n//         const lines = locationsTxt.split('\\n').slice(1);\n//         return lines.map((line) => {\n//             let loc = new Location(line);\n//             // Create a new Location object and add it to the list\n//             console.log('Graph: ')\n//             console.log(Graph.locations);\n//             Graph.locations.push(loc);\n//             Graph.addVertex(loc);\n//             return loc;\n//         })\n//     },\n//     getDistance: getDistance\n// };","import { getHaversineDistance } from './location';\nimport { vehicles } from '../settings/settings';\n\nexport default class Passenger {\n    constructor(name, currentLoc, dest, preference, vehiclePreference) {\n        this.name = name;\n        this.currentLoc = currentLoc;\n        this.dest = dest;\n        this.preference = preference;   // 1 for shortest time, 2 for lowest cost\n        this.vehiclePreference = vehiclePreference;\n        this.path = [];\n        this.cost = 0;\n    }\n\n    setPath (path) {\n        this.path = path;\n    }\n\n    calculateCost(){\n\t\t// typeOfCost: 1 is fixed (regardless of time or distance), 2 is fixed + a factor of distance  (e.g. a Taxi cab),\n\t\t// and 3 is based on fraction of distance (e.g. a Car where unitCost is expressed as cost/gallon)\n\n\t\tlet distance = 0;\n\t\tfor (let i = 0; i < this.path.length -1;i++) distance += getHaversineDistance(this.path[i], this.path[i+1]);\n\n\t\tthis.cost = vehicles.get(this.vehiclePreference).calculateCostOfTravel(distance);\n\n\t\treturn this.cost;\n\n\t}\n}\n","import Vehicle from '../lib/vehicle';\nimport Location, { getDistance } from '../lib/location';\nimport Passenger from '../lib/passenger';\nimport Graph from '../lib/graph';\nimport fs from 'fs';\nimport path from 'path';\nexport let g = new Graph();\nexport let locations = [];\nexport let passengers = [];\nexport let vehicles = new Map();\n\nexport const loadVehicles = () => {\n\trequire(path.join(__dirname, '../src/settings/Vehicles.json')).map(line =>\n\t\tvehicles.set(line.type, new Vehicle(line.name, line.speed, line.wait, line.unitCost, line.costType))\n\t);\n\n\treturn vehicles;\n}\n\nexport const loadLocations = () => {\n\treturn require(path.join(__dirname, '../src/settings/Locations.json')).map((line) => {\n\t\tlet vehiclePayload = [];\n\t\t\n\t\tfor(let i = 0; i < line.vehicleTypes.length; i++)\n\t\t\tline.vehicleTypes[i] ? vehiclePayload.push(vehicles.get(Vehicle.vehicleNames[i])) : vehiclePayload.push(null);\n\n\t\tlet loc = new Location(line.name, line.latitude, line.longitude, line.x, line.y, line.vehicleTypes, vehiclePayload);\n\t\tlocations.push(loc);\n\t\tg.addVertex(loc);\n\t\treturn loc;\n\t});\n}\n\nexport const loadPassengers = () => {\n\treturn require(path.join(__dirname, '../src/settings/People.json')).map((line) => {\n\t\tlet passenger = new Passenger(line.name, g.graph[line.currentLocation], g.graph[line.destination], line.preference, line.vehiclePreference);\n\t\tpassengers.push(passenger);\n\t\treturn passenger;\n\t});\n}\n\nexport const loadPaths = () => {\n\treturn require(path.join(__dirname, '../src/settings/Paths.json')).map((line) => {\n\t\tlet from = g.graph[line.from];\n\t\tlet to = g.graph[line.to];\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tif (from.vehicleTypes[i] && to.vehicleTypes[i])\n\t\t\t\tg.addEdge(from, to, getDistance(from,to), from.vehicles[i]);\n\t\t}\n\t\treturn [from,to];\n\t});\n}","import { loadPassengers, loadVehicles, loadLocations, loadPaths } from './settings/settings';\nimport { locations, g, passengers } from './settings/settings';\nimport { getShortestPathTo } from './lib/graph';\n\nexport const sketch = (p) => {\n  let bg, x, y;\n  let path = [];\n  let passengerIndex = 0;\n  let locIndex = 1;\n  let h = 20;\n  let labels = [];\n\n  p.setup = () => {\n    let canvas = p.createCanvas(1700,900);\n    canvas.parent('root')\n    bg = p.loadImage('../build/icons/Map.PNG');\n    loadVehicles();\n    loadLocations();\n    loadPaths();\n    loadPassengers();\n\n\n    passengers.forEach((passenger) => {\n        g.computePaths(passenger);\n        let personPath = getShortestPathTo(passenger.dest)\n        if (personPath[0] == personPath[1])\n            passenger.setPath([passenger.currentLoc, passenger.currentLoc])\n        else\n            passenger.setPath(personPath)\n\n        console.log(`${passenger.name}'s path using ${passenger.vehiclePreference}:`);\n        let pathString = passenger.path.map(loc => loc.name).join(', ');\n        console.log(`${pathString}`);\n    });\n\n    p.background(255);\n\n    path = passengers[passengerIndex].path;\n    x = path[0].x;\n    y = path[0].y;\n  }\n\n  p.draw = () => {\n    p.image(bg, 0, 0);\n    p.frameRate(30);\n\n    // Map all locations\n    locations.forEach((loc) => {\n        p.fill(255, 0, 0);\n        p.ellipse(loc.x, loc.y, 20,20);\n\n        // San Ramon and Dublin are not on the Google Maps image\n        if (loc.name == (\"San Ramon\") || loc.name == (\"Dublin\")) {\n            p.fill(0);\n            p.textSize(13);\n            p.text(loc.name, loc.x - 30, loc.y - 20);\n        }\n\n        // For each adjacent location, draw a line between them\n        loc.vehicles.forEach((vehicle) => {\n            if (vehicle != null) {\n                loc.adjacent.get(vehicle).forEach((e) => {\n                    p.line(loc.x, loc.y, e.to.x, e.to.y);\n                });\n            }\n        });\n    });\n\n    x = p.lerp(parseFloat(x), parseFloat(path[locIndex].x), 0.1);\n    y = p.lerp(parseFloat(y), parseFloat(path[locIndex].y), 0.1);\n\n    // Create a circle that represents the current passenger as they traverse the graph and add their name above it\n    p.fill(0,175,255);\n    p.ellipse(x,y,25,25);\n    p.fill(0);\n    p.text(passengers[passengerIndex].name, x-10, y);\n\n    // Once a passenger arrives at their next location, if they arrive at their destination, go to the next person, otherwise, go to next location\n    if (Math.abs(x - parseFloat(path[locIndex].x)) < 1 || Math.abs(y - parseFloat(path[locIndex].y)) < 1){\n        let changedPaths = false;\n\n        // If passenger has reached their destination\n        if ((locIndex + 1) == path.length) {\n            // If last passenger has reached their destination\n            if ((passengerIndex + 1) == passengers.length) {\n                console.log(\"FINISHED!\");\n                // Print the last person's name at their finishing position\n                p.fill(60, 0, 110);\n                p.textSize(20);\n                p.text(passengers[passengerIndex].name, x-10, y-20);\n\n                // Print all passenger's paths in the white space to the right\n                passengers.forEach((passenger) => {\n                    // If passenger could not find a path to their destination, their path would be: [currentLoc, currentLoc]\n                    if (passenger.path[0] == passenger.path[1]) \n                        p.text(`No possible path for ${passenger.name} to go from ${passenger.currentLoc.name} to ${passenger.dest.name} using a %s\\n`, 720, h);\n                    \n                    else\n                        p.text(`${passenger.name}'s path: ${passenger.path.map(loc => loc.name).join(', ')} Using: ${passenger.vehiclePreference}   Total Cost: ${passenger.calculateCost().toLocaleString('en-US', { style: \"currency\", currency: \"USD\" })}\\n`, 720,h);\n                    \n                    h += 20;\n                })\n\n\n                // Stop drawing\n                p.noLoop();\n            }\n\n            // If passenger has reached their destination, get next passenger\n            else {\n                labels.push({\n                    \"name\": passengers[passengerIndex].name,\n                    \"x\": x-10,\n                    \"y\": y-20\n                });\n                passengerIndex++;\n                locIndex = 1;\n                changedPaths = true;\n            }\n        }\n\n        // Otherwise, continue to the next location\n        else{\n            locIndex++;\n        }\n\n        path = passengers[passengerIndex].path;\n\n        // If passenger has changed, set x and y to the coordinates of their current location\n        if (changedPaths) {\n            x = path[0].x;\n            y = path[0].y;\n        }\n    }\n\n    labels.forEach((label) => {\n        p.fill(60, 0, 110);\n        p.textSize(20);\n        p.text(label.name, label.x, label.y);\n    });\n  }\n\n  p.mousePressed = (e) => {\n\tconsole.log(`(${e.x}, ${e.y})`);\n  }\n}","// Here is the starting point for your application code.\n\n// Small helpers you might want to keep\n// import './helpers/context_menu.js';\n// import './helpers/external_links.js';\n\n// All stuff below is just to show you how it works. You can delete all of it.\n\nimport p5 from 'p5';\nimport { sketch } from './sketch';\n\nnew p5(sketch);"],"names":["Vehicle","name","speedOfTravel","waitTime","unitCost","typeOfCost","toString","_this","location","undefined","distance","this","vehicleNames","Graph","graph","node","from","to","weight","type","containsLocation","addVertex","addNeighbor","p","source","currentLoc","values","forEach","x","dist","Infinity","prev","vertexQueue","TinyQueue","a","b","push","peek","u","pop","vehiclePreference","adjacent","get","vehicles","e","v","alt","data","filter","loc","getShortestPathTo","target","path","vertex","reverse","length","Edge","vehicleType","require","Location","latitude","longitude","y","vehicleTypes","neighbor","vehicle","includes","lat","lon","Map","set","getDistance","loc1","loc2","Math","sqrt","pow","getHaversineDistance","l1","l2","lat1","lon1","lat2","lon2","φ1","PI","φ2","Δφ","Δλ","sin","cos","atan2","Passenger","dest","preference","cost","i","calculateCostOfTravel","g","locations","passengers","loadVehicles","join","__dirname","map","line","speed","wait","costType","loadLocations","vehiclePayload","loadPassengers","passenger","currentLocation","destination","loadPaths","addEdge","sketch","bg","passengerIndex","locIndex","h","labels","setup","createCanvas","parent","loadImage","computePaths","personPath","setPath","log","pathString","background","draw","image","frameRate","fill","ellipse","textSize","text","lerp","parseFloat","abs","changedPaths","calculateCost","toLocaleString","style","currency","noLoop","label","mousePressed","p5"],"mappings":"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"}